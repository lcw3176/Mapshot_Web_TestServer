"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var LatLng = /*#__PURE__*/function () {
  function LatLng(lat, lng) {
    _classCallCheck(this, LatLng);

    this.x;
    this.y;

    if (lat != undefined && lng != undefined) {
      this.init(lat, lng);
    }
  }

  _createClass(LatLng, [{
    key: "init",
    value: function init(lat, lng) {
      if (lat > lng) {
        this.x = lat;
        this.y = lng;
      } else {
        this.x = lng;
        this.y = lat;
      }
    }
  }, {
    key: "getX",
    value: function getX() {
      return this.x;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }
  }]);

  return LatLng;
}();

var NFixLat = /*#__PURE__*/function () {
  function NFixLat() {
    _classCallCheck(this, NFixLat);

    this.width;
    this.height; // 로고 없을 때

    this.logoHeight; // 로고 있을 때
  }

  _createClass(NFixLat, [{
    key: "generate",
    value: function generate(latlng, naverProfile) {
      var correctFix;
      var controlPoint = 37.5668;

      switch (naverProfile.getLevel()) {
        case 16:
          correctFix = 0.00011633;
          this.width = 0.01072;
          this.height = 0.00829;
          this.logoHeight = 0.00817;
          break;

        case 18:
          correctFix = 0.00002833;
          this.width = 0.00268;
          this.height = 0.002070;
          this.logoHeight = 0.00204;
          break;

        default:
          break;
      }

      this.height += (controlPoint - latlng.getY()) * correctFix;
      this.logoHeight += (controlPoint - latlng.getY()) * correctFix;
    }
  }, {
    key: "getWidthBetweenBlock",
    value: function getWidthBetweenBlock() {
      return this.width;
    }
  }, {
    key: "getHeightBetweenBlock",
    value: function getHeightBetweenBlock() {
      return this.height;
    }
  }, {
    key: "getHeightBetweenBlockWithLogo",
    value: function getHeightBetweenBlockWithLogo() {
      return this.logoHeight;
    }
  }]);

  return NFixLat;
}();

var Tile = /*#__PURE__*/function () {
  function Tile() {
    _classCallCheck(this, Tile);
  }

  _createClass(Tile, [{
    key: "getSE",
    value: function getSE(sideBlockCount, NFixLat, coor) {
      var Lat = coor.getY() - NFixLat.getHeightBetweenBlock() * parseInt(sideBlockCount / 2) - NFixLat.getHeightBetweenBlock() / 2;
      var Lng = coor.getX() + NFixLat.getWidthBetweenBlock() * parseInt(sideBlockCount / 2) + NFixLat.getWidthBetweenBlock() / 2;
      return new mapshot.coors.LatLng(Lat, Lng);
    }
  }, {
    key: "getSW",
    value: function getSW(sideBlockCount, NFixLat, coor) {
      var Lat = coor.getY() - NFixLat.getHeightBetweenBlock() * parseInt(sideBlockCount / 2) - NFixLat.getHeightBetweenBlock() / 2;
      var Lng = coor.getX() - NFixLat.getWidthBetweenBlock() * parseInt(sideBlockCount / 2) - NFixLat.getWidthBetweenBlock() / 2;
      return new mapshot.coors.LatLng(Lat, Lng);
    }
  }, {
    key: "getNE",
    value: function getNE(sideBlockCount, NFixLat, coor) {
      var Lat = coor.getY() + NFixLat.getHeightBetweenBlock() * parseInt(sideBlockCount / 2) + NFixLat.getHeightBetweenBlock() / 2;
      var Lng = coor.getX() + NFixLat.getWidthBetweenBlock() * parseInt(sideBlockCount / 2) + NFixLat.getWidthBetweenBlock() / 2;
      return new mapshot.coors.LatLng(Lat, Lng);
    }
  }, {
    key: "getNW",
    value: function getNW(sideBlockCount, NFixLat, coor) {
      var Lat = coor.getY() + NFixLat.getHeightBetweenBlock() * parseInt(sideBlockCount / 2) + NFixLat.getHeightBetweenBlock() / 2;
      var Lng = coor.getX() - NFixLat.getWidthBetweenBlock() * parseInt(sideBlockCount / 2) - NFixLat.getWidthBetweenBlock() / 2;
      return new mapshot.coors.LatLng(Lat, Lng);
    }
  }]);

  return Tile;
}();

var Naver = /*#__PURE__*/function () {
  function Naver() {
    _classCallCheck(this, Naver);

    this.mapType;
    this.center;
    this.level;
    this.key;
    this.width;
    this.height;
  }

  _createClass(Naver, [{
    key: "setMapType",
    value: function setMapType(param) {
      this.mapType = param;
    }
  }, {
    key: "getMapType",
    value: function getMapType() {
      return this.mapType;
    }
  }, {
    key: "setCenter",
    value: function setCenter(param) {
      this.center = param;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
  }, {
    key: "setLevel",
    value: function setLevel(param) {
      this.level = param;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this.level;
    }
  }, {
    key: "setKey",
    value: function setKey(param) {
      this.key = param;
    }
  }, {
    key: "getKey",
    value: function getKey() {
      return this.key;
    }
  }, {
    key: "setWidth",
    value: function setWidth(param) {
      this.width = param;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
  }, {
    key: "setHeight",
    value: function setHeight(param) {
      this.height = param;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }
  }, {
    key: "getUrl",
    value: function getUrl() {
      return "https://naveropenapi.apigw.ntruss.com/map-static/v2/raster-cors?" + "w=" + this.width + "&h=" + this.height + "&center=" + this.center.getX() + "," + this.center.getY() + "&level=" + this.level + "&X-NCP-APIGW-API-KEY-ID=" + this.key + "&maptype=" + this.mapType;
    }
  }]);

  return Naver;
}();

var mapshot;
window.addEventListener("load", function () {
  mapshot = {
    maps: {
      Tile: Tile
    },
    coors: {
      NFixLat: NFixLat,
      LatLng: LatLng
    },
    profile: {
      Naver: Naver
    }
  };
});

var Map = /*#__PURE__*/function () {
  function Map() {
    _classCallCheck(this, Map);

    _defineProperty(this, "init", function () {
      kakao.maps.event.addListener(this.map, 'click', function (mouseEvent) {
        this.searchDetailAddrFromCoords(mouseEvent.latLng, function (result, status) {
          if (status === kakao.maps.services.Status.OK) {
            var loadAddress = !!result[0].road_address ? result[0].road_address.address_name : '';
            var bunziAddress = result[0].address.address_name;
            document.getElementById("load-address").innerText = loadAddress == null ? "" : loadAddress;
            document.getElementById("bunzi-address").innerText = bunziAddress == null ? "" : bunziAddress;
          }
        }.bind(this));
      }.bind(this));
      kakao.maps.event.addListener(this.map, 'idle', function () {
        this.searchAddrFromCoords(this.map.getCenter(), this.displayCenterInfo);
      }.bind(this));
    });

    _defineProperty(this, "searchAddrFromCoords", function (coords, callback) {
      // 좌표로 행정동 주소 정보를 요청합니다
      this.geocoder.coord2RegionCode(coords.getLng(), coords.getLat(), callback);
    });

    _defineProperty(this, "searchDetailAddrFromCoords", function (coords, callback) {
      // 좌표로 법정동 상세 주소 정보를 요청합니다
      this.geocoder.coord2Address(coords.getLng(), coords.getLat(), callback);
    });

    _defineProperty(this, "displayCenterInfo", function () {});

    _defineProperty(this, "searchPlaces", function () {
      var keyword = document.getElementById('keyword').value;

      if (!keyword.replace(/^\s+|\s+$/g, '')) {
        alert('키워드를 입력해주세요!');
        return false;
      }

      this.ps.keywordSearch(keyword, this.placesSearchCB);
    });

    _defineProperty(this, "placesSearchCB", function (data, status, pagination) {
      if (status === kakao.maps.services.Status.OK) {
        this.displayPlaces(data);
        this.displayPagination(pagination);
      } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
        alert('검색 결과가 존재하지 않습니다.');
        return;
      } else if (status === kakao.maps.services.Status.ERROR) {
        alert('검색 결과 중 오류가 발생했습니다.');
        return;
      }
    }.bind(this));

    _defineProperty(this, "displayPlaces", function (places) {
      var listEl = document.getElementById('placesList');
      var menuEl = document.getElementById('menu_wrap');
      var fragment = document.createDocumentFragment();
      var bounds = new kakao.maps.LatLngBounds();
      this.removeAllChildNods(listEl);
      this.removeMarker();

      for (var i = 0; i < places.length; i++) {
        // 마커를 생성하고 지도에 표시합니다
        var placePosition = new kakao.maps.LatLng(places[i].y, places[i].x);
        var marker = this.addMarker(placePosition, i);
        var itemEl = this.getListItem(i, places[i]); // 검색 결과 항목 Element를 생성합니다

        bounds.extend(placePosition);
        (function (marker, title) {
          kakao.maps.event.addListener(marker, 'mouseover', function () {
            this.displayInfowindow(marker, title);
          }.bind(this));
          kakao.maps.event.addListener(marker, 'mouseout', function () {
            this.infoWindow.close();
          }.bind(this));

          itemEl.onmouseover = function () {
            this.displayInfowindow(marker, title);
          }.bind(this);

          itemEl.onmouseout = function () {
            this.infoWindow.close();
          }.bind(this);
        }).bind(this)(marker, places[i].place_name);
        fragment.appendChild(itemEl);
      }

      listEl.appendChild(fragment);
      menuEl.scrollTop = 0;
      this.map.setBounds(bounds);
    }.bind(this));

    _defineProperty(this, "getListItem", function (index, places) {
      var el = document.createElement('li'),
          itemStr = '<span class="markerbg marker_' + (index + 1) + '"></span>' + '<div class="info">' + '   <h5>' + places.place_name + '</h5>';

      if (places.road_address_name) {
        itemStr += '    <span>' + places.road_address_name + '</span>' + '   <span class="jibun gray">' + places.address_name + '</span>';
      } else {
        itemStr += '    <span>' + places.address_name + '</span>';
      }

      itemStr += '  <span class="tel">' + places.phone + '</span>' + '</div>';
      el.innerHTML = itemStr;
      el.className = 'item';
      return el;
    });

    _defineProperty(this, "removeMarker", function () {
      for (var i = 0; i < this.markers.length; i++) {
        this.markers[i].setMap(null);
      }

      this.markers = [];
    });

    _defineProperty(this, "addMarker", function (position, idx, title) {
      var imageSrc = 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_number_blue.png',
          // 마커 이미지 url, 스프라이트 이미지를 씁니다
      imageSize = new kakao.maps.Size(36, 37),
          // 마커 이미지의 크기
      imgOptions = {
        spriteSize: new kakao.maps.Size(36, 691),
        // 스프라이트 이미지의 크기
        spriteOrigin: new kakao.maps.Point(0, idx * 46 + 10),
        // 스프라이트 이미지 중 사용할 영역의 좌상단 좌표
        offset: new kakao.maps.Point(13, 37) // 마커 좌표에 일치시킬 이미지 내에서의 좌표

      },
          markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imgOptions),
          marker = new kakao.maps.Marker({
        position: position,
        // 마커의 위치
        image: markerImage
      });
      marker.setMap(this.map); // 지도 위에 마커를 표출합니다

      this.markers.push(marker); // 배열에 생성된 마커를 추가합니다

      return marker;
    });

    _defineProperty(this, "displayPagination", function (pagination) {
      var paginationEl = document.getElementById('pagination'),
          fragment = document.createDocumentFragment(),
          i; // 기존에 추가된 페이지번호를 삭제합니다

      while (paginationEl.hasChildNodes()) {
        paginationEl.removeChild(paginationEl.lastChild);
      }

      for (i = 1; i <= pagination.last; i++) {
        var el = document.createElement('a');
        el.href = "#";
        el.innerHTML = i;

        if (i === pagination.current) {
          el.className = 'on';
        } else {
          el.onclick = function (i) {
            return function () {
              pagination.gotoPage(i);
            };
          }(i);
        }

        fragment.appendChild(el);
      }

      paginationEl.appendChild(fragment);
    });

    _defineProperty(this, "displayInfowindow", function (marker, title) {
      var content = '<div style="padding:5px;z-index:1;">' + title + '</div>';
      this.infoWindow.setContent(content);
      this.infoWindow.open(this.map, marker);
    });

    _defineProperty(this, "removeAllChildNods", function (el) {
      while (el.hasChildNodes()) {
        el.removeChild(el.lastChild);
      }
    });

    this.markers = [];
    this.mapContainer = document.getElementById('map');
    this.mapOption = {
      center: new kakao.maps.LatLng(37.566826, 126.9786567),
      // 지도의 중심좌표
      level: 8 // 지도의 확대 레벨

    };
    this.map = new kakao.maps.Map(this.mapContainer, this.mapOption);
    this.ps = new kakao.maps.services.Places();
    this.infoWindow = new kakao.maps.InfoWindow({
      zIndex: 1
    });
    this.geocoder = new kakao.maps.services.Geocoder();
    this.marker = new kakao.maps.Marker();
    this.init();
  }

  _createClass(Map, [{
    key: "getMap",
    value: function getMap() {
      return this.map;
    }
  }]);

  return Map;
}();

window.onload = function () {
  var naverProfile = new mapshot.profile.Naver();
  naverProfile.setKey("ny5d4sdo0e");
  naverProfile.setWidth(1000);
  naverProfile.setHeight(1000);
  var coor = new mapshot.coors.LatLng();
  var nFix = new mapshot.coors.NFixLat();
  var tile = new mapshot.maps.Tile();
  var map = new Map();
  var rectangle = null;
  var blockCount = 0;
  var traceMode = false;
  var resultType = null;
  var km;
  var kakaoMapType;
  var url = null; // 카카오 지도 설정

  document.getElementById("searchPlaces").onsubmit = function () {
    map.searchPlaces();
    return false;
  };

  kakao.maps.event.addListener(map.getMap(), 'click', function (mouseEvent) {
    coor.init(mouseEvent.latLng.getLat(), mouseEvent.latLng.getLng());
    document.getElementById("lat").innerText = coor.getY();
    document.getElementById("lng").innerText = coor.getX();
    nFix.generate(coor, naverProfile);

    if (rectangle != null) {
      rectangle.setMap(null);
    }

    var sw = tile.getSW(blockCount, nFix, coor);
    var ne = tile.getNE(blockCount, nFix, coor);
    rectangle = new kakao.maps.Rectangle({
      bounds: new kakao.maps.LatLngBounds(new kakao.maps.LatLng(sw.getY(), sw.getX()), new kakao.maps.LatLng(ne.getY(), ne.getX())),
      strokeWeight: 4,
      strokeColor: '#FF3DE5',
      strokeOpacity: 1,
      strokeStyle: 'shortdashdot',
      fillColor: '#FF8AEF',
      fillOpacity: 0.8
    });
    rectangle.setMap(map.getMap());
  });

  document.getElementById("map").onmousedown = function (e) {
    if (e.button == 2 && rectangle != null) {
      rectangle.setMap(null);
    }
  }; // 지도 설정 끝


  setZoomLevel = function setZoomLevel(sideBlockCount, level, _km, id) {
    var matches = document.getElementsByClassName("zoom");

    for (var i = 0; i < matches.length; i++) {
      matches[i].setAttribute('class', 'zoom');
    }

    blockCount = sideBlockCount;
    naverProfile.setLevel(level);
    km = _km;
    id.setAttribute('class', 'zoom is-active');
  };

  setBaseMap = function setBaseMap(mapType, id) {
    var matches = document.getElementsByClassName("map");

    for (var i = 0; i < matches.length; i++) {
      matches[i].setAttribute('class', 'map');
    }

    naverProfile.setMapType(mapType);
    kakaoMapType = mapType;
    id.setAttribute('class', 'map is-active');
  };

  setTraceMode = function setTraceMode(id) {
    if (id.getAttribute("class") != "is-active") {
      id.setAttribute("class", "is-active");
      traceMode = true;
    } else {
      id.setAttribute("class", "");
      traceMode = false;
    }
  };

  setCompany = function setCompany(companyName, id) {
    var matches = document.getElementsByClassName("company");

    for (var i = 0; i < matches.length; i++) {
      matches[i].setAttribute('class', 'company');
    }

    if (companyName === "kakao") {
      id.setAttribute("class", "company button is-warning");
    } else if (companyName === "naver") {
      id.setAttribute("class", "company button is-success");
    }

    resultType = companyName;
  };

  startCapture = function startCapture() {
    if (url != null) {
      URL.revokeObjectURL(url);
    }

    if (coor.getX() == undefined || coor.getY() == undefined) {
      alert("좌표 설정을 먼저 진행해 주세요.");
      return;
    }

    if (resultType == null) {
      alert("출력 타입을 지정해주세요");
      return;
    }

    if (traceMode) {
      var traceRec = new kakao.maps.Rectangle({
        bounds: rectangle.getBounds(),
        strokeWeight: 4,
        strokeColor: '#000000',
        strokeOpacity: 1,
        strokeStyle: 'shortdot',
        fillColor: '#ecf4f3',
        fillOpacity: 0.8
      });
      traceRec.setMap(map.getMap());
    }

    if (resultType === "kakao") {
      kakaoCapture();
    } else if (resultType === "naver") {
      naverCapture();
    }
  };

  kakaoCapture = function kakaoCapture() {
    var requestUrl = "https://mapshotproxyserver.herokuapp.com/test?";
    var queryString = "lat=" + coor.getY() + "&lng=" + coor.getX() + "&level=" + km + "&type=" + kakaoMapType;
    requestUrl += queryString;
    var progressBar = document.getElementById("progressBar");
    progressBar.removeAttribute("value");
    var img = new Image();
    img.src = requestUrl;
    img.crossOrigin = "*";
    document.getElementById("captureStatus").innerText = "서버에 요청중입니다. 잠시 기다려주세요";

    img.onload = function () {
      var canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);

      if (canvas.msToBlob) {
        canvas.toBlob(function (blob) {
          navigator.msSaveBlob(blob, "mapshot_result.jpg");
          document.getElementById("captureStatus").innerText = "완료되었습니다.";
        }, "image/jpeg");
      } else {
        canvas.toBlob(function (blob) {
          url = URL.createObjectURL(blob);
          var tag = document.getElementById("resultHref");
          tag.href = url;
          tag.download = "mapshot_result.jpg";
          var span = document.getElementById("resultSpan");
          span.innerHTML = "mapshot_result.jpg";
          document.getElementById("captureStatus").innerText = "완료되었습니다. 생성된 링크를 확인하세요";
        }, "image/jpeg");
      }

      progressBar.setAttribute("value", 100);
    };

    img.onerror = function () {
      document.getElementById("captureStatus").innerText = "서버 에러입니다. 잠시 후 다시 시도해주세요.";
      progressBar.setAttribute("value", 0);
    };
  };

  naverCapture = function naverCapture() {
    var canvasBlockSize = blockCount <= 11 ? 1000 : 500;
    var progressAddValue = 100 / (blockCount * blockCount);
    var progressBar = document.getElementById("progressBar");
    progressBar.value = 0;
    var temp = tile.getNW(blockCount, nFix, coor);
    var startCoor = new mapshot.coors.LatLng(temp.getX() + nFix.getWidthBetweenBlock() / 2, temp.getY() - nFix.getHeightBetweenBlock() / 2);
    var returnXValue = startCoor.getX();
    var canvas = document.createElement("canvas");
    canvas.width = blockCount * canvasBlockSize;
    canvas.height = blockCount * canvasBlockSize;
    var ctx = canvas.getContext("2d");
    var captureStatusTag = document.getElementById("captureStatus");
    var order = 0;
    var logoRemover = 26;
    var imageLoadCount = 0;

    for (var i = 0; i < blockCount; i++) {
      for (var j = 0; j < blockCount; j++) {
        if (i + 1 === blockCount && j === 0) {
          naverProfile.setHeight(1000 - logoRemover);
          startCoor.init(startCoor.getX(), startCoor.getY() + nFix.getHeightBetweenBlock());
          startCoor.init(startCoor.getX(), startCoor.getY() - nFix.getHeightBetweenBlockWithLogo());
        }

        naverProfile.setCenter(startCoor);
        var image = new Image();
        image.src = naverProfile.getUrl();
        image.crossOrigin = "*";

        (function (_order, _image) {
          var xPos = _order % blockCount * canvasBlockSize;
          var yPos = parseInt(_order / blockCount) * canvasBlockSize;

          _image.onload = function () {
            ctx.drawImage(_image, 0, 0, _image.width, 1000 - logoRemover, xPos, yPos, canvasBlockSize, canvasBlockSize);
            imageLoadCount++;
            captureStatusTag.innerText = imageLoadCount + "/" + blockCount * blockCount + " 수집 완료";
            progressBar.value += progressAddValue;

            if (imageLoadCount == blockCount * blockCount) {
              mergeImageBlock();
            }
          };

          _image.onerror = function () {
            imageLoadCount++;
            captureStatusTag.innerText = imageLoadCount + "/" + blockCount * blockCount + " 수집 완료";
            progressBar.value += progressAddValue;
            progressBar.setAttribute("class", "progress is-danger");

            if (imageLoadCount == blockCount * blockCount) {
              mergeImageBlock();
            }
          };
        })(order, image);

        order++;
        startCoor.init(startCoor.getX() + nFix.getWidthBetweenBlock(), startCoor.getY());

        if (i + 1 === blockCount && j === 0) {
          naverProfile.setHeight(1000);
          startCoor.init(startCoor.getX(), startCoor.getY() + nFix.getHeightBetweenBlockWithLogo());
          startCoor.init(startCoor.getX(), startCoor.getY() - nFix.getHeightBetweenBlock());
        }
      }

      startCoor.init(returnXValue, startCoor.getY() - nFix.getHeightBetweenBlock());
    }

    function mergeImageBlock() {
      if (canvas.msToBlob) {
        canvas.toBlob(function (blob) {
          navigator.msSaveBlob(blob, "mapshot_result.jpg");
          var status = document.getElementById("captureStatus");
          status.innerText = "완료되었습니다.";
        }, "image/jpeg");
      } else {
        canvas.toBlob(function (blob) {
          url = URL.createObjectURL(blob);
          var tag = document.getElementById("resultHref");
          tag.href = url;
          tag.download = "mapshot_result.jpg";
          var span = document.getElementById("resultSpan");
          span.innerHTML = "mapshot_result.jpg";
          document.getElementById("captureStatus").innerText = "완료되었습니다. 생성된 링크를 확인하세요";
        }, "image/jpeg");
      }
    }
  };

  document.getElementById("default_click_level").click();
  document.getElementById("default_click_map").click();
  document.getElementById("setTrace").click();
};